/*
 * ar0234_mode_tbls.h - ar0234 sensor mode tables
 *
 * Copyright (c) 2018-2023, NVIDIA CORPORATION.  All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms and conditions of the GNU General Public License,
 * version 2, as published by the Free Software Foundation.
 *
 * This program is distributed in the hope it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#ifndef __AR0234_I2C_TABLES__
#define __AR0234_I2C_TABLES__

#include <media/camera_common.h>

#define AR0234_TABLE_WAIT_MS	0xff00
#define AR0234_TABLE_END	0xff01
#define AR0234_MAX_RETRIES	3
#define AR0234_WAIT_MS_STOP	1
#define AR0234_WAIT_MS_START	30
#define AR0234_WAIT_MS_STREAM	210
#define AR0234_GAIN_TABLE_SIZE 255

#define AR0234_EEPROM_ADDRESS		0x54
#define AR0234_EEPROM_ADDRESS_R         0x58
#define AR0234_EEPROM_SIZE              512
#define AR0234_EEPROM_STR_SIZE          (AR0234_EEPROM_SIZE * 2)
#define AR0234_EEPROM_BLOCK_SIZE        (1 << 8)
#define AR0234_EEPROM_NUM_BLOCKS \
	(AR0234_EEPROM_SIZE / AR0234_EEPROM_BLOCK_SIZE)


#define ar0234_reg struct reg_16

struct index_reg_8 {
	u16 source;
	u16 addr;
	u16 val;
};

static struct index_reg_8 ar0234_start[] = {
	{0x06, 0x30CE, 0x0120}, // sync mode
	{0x06, 0x301A, 0x295C}, // stream = 1, forced_pll_on = 1, gpi_en = 1

	{0x00, AR0234_TABLE_END, 0x00}
};

static struct index_reg_8 ar0234_stop[] = {
	{0x06, 0x301A, 0x2058}, // stream = 0, forced_pll_on = 0, gpi_en = 0

	{0x00, AR0234_TABLE_END, 0x00}
};

#if 0

static struct index_reg_8 ar0234_Double_Dser_Ser[] = {
	{0x52, 0x1458, 0x28},
	{0x52, 0x1459, 0x68},
	{0x52, 0x1558, 0x28},
	{0x52, 0x1559, 0x68},
	{0x52, 0x1658, 0x28},
	{0x52, 0x1659, 0x68},
	{0x52, 0x1758, 0x28},
	{0x52, 0x1759, 0x68},

	{0x52, 0x0018, 0x0F}, // Oneshot reset
	{0x52, 0x0006, 0xF3}, // Enable links A and B
	{0x52, 0x0001, 0xcc}, // disable the i2c2

	{0x52, 0x0003, 0xAE}, // Disable CC to link B
	{0x80, 0x0000, 0x84}, // Link A serializer address is 0x84
	{0x52, 0x0003, 0xAB}, // Disable CC to link A
	{0x80, 0x0000, 0x88}, // Link B serializer address is 0x88
	{0x52, 0x0003, 0xAA}, // Enable CC to links A and B
	{0x84, 0x0002, 0x33}, // Enable pipes X and Y
	{0x84, 0x0308, 0x7E}, // Pipe X pulls clock from port A, pipe Y from port B
	{0x84, 0x0311, 0x21}, // Pipe X pulls data from port A, pipe Y from port B
	{0x84, 0x0316, 0x6b}, // RAW10 to pipe Y
	{0x84, 0x0314, 0x6b}, // RAW10 to pipe X
	{0x88, 0x0002, 0x33}, // Enable pipes X and Y
	{0x88, 0x0308, 0x7E}, // Pipe X pulls clock from port A, pipe Y from port B
	{0x88, 0x0311, 0x21}, // Pipe X pulls data from port A, pipe Y from port B
	{0x88, 0x0316, 0x6b}, // RAW10 to pipe Y
	{0x88, 0x0314, 0x6b}, // RAW10 to pipe X
	{0x52, 0x00F4, 0x0f}, // Enable pipes 0-3 in deserializer
	{0x52, 0x00F0, 0x10}, // Link A ID 0 to pipe 0 // Link A ID 1 to pipe 1
	{0x52, 0x00F1, 0x54}, // Link B ID 0 to pipe 2  // Link B ID 1 to pipe 3

	{0x52, 0x08A0, 0x01}, // CSI output is 4x2
	{0x52, 0x08A3, 0x44}, // Default 4x2 lane mapping
	{0x52, 0x08A4, 0x44}, // Default 4x2 lane mapping

	{0x52, 0x090A, 0x40},
	{0x52, 0x094A, 0x40}, // 2 lanes on port D
	{0x52, 0x098A, 0x40}, // 2 lanes on port E
	{0x52, 0x09CA, 0x40},

	{0x52, 0x1D00, 0xF4},
	{0x52, 0x1E00, 0xF4},

	{0x52, 0x0415, 0x39},
	{0x52, 0x0418, 0x39},	// Date rate is 2500Mbps/lane on port D
	{0x52, 0x041B, 0x39},	// Data rate is 2500Mbps/lane on port E
	{0x52, 0x041E, 0x39},

	{0x52, 0x1D00, 0xF5},
	{0x52, 0x1E00, 0xF5},

	{0x52, 0x090B, 0x07}, // Enable 3 mappings  Pipe 0//video2
	{0x52, 0x092D, 0x00}, // All mappings to controller 0 (port C)
	{0x52, 0x090D, 0x2B}, // Input RAW10, VC0
	{0x52, 0x090E, 0x2B}, // Output RAW10, VC0
	{0x52, 0x090F, 0x00}, // Input FS, VC0
	{0x52, 0x0910, 0x00}, // Output FS, VC0
	{0x52, 0x0911, 0x01}, // Input FE, VC0
	{0x52, 0x0912, 0x01}, // Output FE, VC0

	{0x52, 0x094B, 0x07}, // Enable 3 mappings  Pipe 1  //video3
	{0x52, 0x096D, 0x00}, // All mappings to controller 0 (port C)
	{0x52, 0x094D, 0x2B}, // Input RAW10, VC0
	{0x52, 0x094E, 0x6B}, // Output RAW10, VC1
	{0x52, 0x094F, 0x00}, // Input FS, VC0
	{0x52, 0x0950, 0x40}, // Output FS, VC1
	{0x52, 0x0951, 0x01}, // Input FE, VC0
	{0x52, 0x0952, 0x41}, // Output FE, VC1

	{0x52, 0x098B, 0x07}, // Enable 3 mappings Pipe 2  //video1
	{0x52, 0x09AD, 0x15}, // All mappings to controller 1 (port D)
	{0x52, 0x098D, 0x2B}, // Input RAW10, VC0
	{0x52, 0x098E, 0x2B}, // Output RAW10, VC0
	{0x52, 0x098F, 0x00}, // Input FS, VC0
	{0x52, 0x0990, 0x00}, // Output FS, VC0
	{0x52, 0x0991, 0x01}, // Input FE, VC0
	{0x52, 0x0992, 0x01}, // Output FE, VC0

	{0x52, 0x09CB, 0x07}, // Enable 3 mappings  Pipe 3  //video0
	{0x52, 0x09ED, 0x15}, // All mappings to controller 1 (port D)
	{0x52, 0x09CD, 0x2B}, // Input RAW10, VC0
	{0x52, 0x09CE, 0x6B}, // Output RAW10, VC1
	{0x52, 0x09CF, 0x00}, // Input FS, VC0
	{0x52, 0x09D0, 0x40}, // Output FS, VC1
	{0x52, 0x09D1, 0x01}, // Input FE, VC0
	{0x52, 0x09D2, 0x41}, // Output FE, VC1


	{0x52, 0x08A2, 0xF0},
	{0x84, 0x02be, 0x90}, // Enable sensor power down pin.
	{0x84, 0x02bf, 0x60}, // Enable sensor reset pin.
	{0x84, 0x02ca, 0x80}, // Enable sensor power down pin.
	{0x84, 0x02cb, 0x60}, // Enable sensor reset pin.
	{0x84, 0x02d3, 0x90}, // Enable sensor power down pin.
	{0x84, 0x02d4, 0x60}, // Enable sensor reset pin.
	{0x84, 0x02d6, 0x90}, // Enable sensor power down pin.
	{0x84, 0x02d7, 0x60}, // Enable sensor reset pin.
	{0x88, 0x02be, 0x90}, // Enable sensor power down pin.
	{0x88, 0x02bf, 0x60}, // Enable sensor reset pin.
	{0x88, 0x02ca, 0x80}, // Enable sensor power down pin.
	{0x88, 0x02cb, 0x60}, // Enable sensor reset pin.
	{0x88, 0x02d3, 0x90}, // Enable sensor power down pin.
	{0x88, 0x02d4, 0x60}, // Enable sensor reset pin.
	{0x88, 0x02d6, 0x90}, // Enable sensor power down pin.
	{0x88, 0x02d7, 0x60}, // Enable sensor reset pin.


	{0x52, 0x04AF, 0xC0}, // AUTO_FS_LINKS = 0, FS_USE_XTAL = 1, FS_LINK_[3:0] = 0
	{0x52, 0x04A0, 0x00}, // Manual frame sync, no pin output

	{0x52, 0x04A2, 0x00}, // Turn off auto master link selection
	{0x52, 0x04AA, 0x00}, // OVLP window = 0
	{0x52, 0x04AB, 0x00},

	{0x52, 0x04A5, 0x35}, // 30Hz FSYNC
	{0x52, 0x04A6, 0xB7},
	{0x52, 0x04A7, 0x0C},

	{0x84, 0x02D9, 0x04},
	{0x84, 0x02DB, 0x08},
	{0x84, 0x02Dc, 0x04},
	{0x84, 0x02De, 0x08}, // MFP8 for FSIN

	{0x88, 0x02D9, 0x04},
	{0x88, 0x02DB, 0x08},
	{0x88, 0x02Dc, 0x04},
	{0x88, 0x02De, 0x08}, // MFP8 for FSIN

	{0x52, 0x04B1, 0x40}, // FSYNC TX ID is 8

	{0x84, 0x0042, 0xB0}, // eeprom i2c map
	{0x84, 0x0043, 0xA8},
	{0x84, 0x0044, 0xB2},
	{0x84, 0x0045, 0xAA},

	{0x88, 0x0042, 0xB0}, // eeprom i2c map
	{0x88, 0x0043, 0xA8},
	{0x88, 0x0044, 0xB2},
	{0x88, 0x0045, 0xAA},

	{0x84, 0x02be, 0x83}, // hawk1(0x84) max9295D MFP0-- ACCEL interrupt
	{0x84, 0x02bf, 0x11},
	{0x52, 0x030c, 0x04}, // max96712 MTF4---ACCEL1 interrupt
	{0x52, 0x030e, 0x11}, // MTF4

	{0x84, 0x02c7, 0x83}, // hawk1(0x84)max9295D MFP3-- gyro interrupt
	{0x84, 0x02c8, 0x12},
	{0x52, 0x0320, 0x04}, // max96712 MTF10---gyro1 interrupt
	{0x52, 0x0322, 0x12}, // MTF10

	{0x88, 0x02BE, 0x03}, // Disable output, enable TX hawk2(0x88) max9295D MFP0-- ACCEL interrupt
	{0x88, 0x02BF, 0x00}, // No pull-up/down, TX ID = 0
	{0x52, 0x0310, 0x00}, // Enable output    max96712 MTF5---ACCEL2 interrupt
	{0x52, 0x0347, 0x05}, // Disable TX on link B
	{0x52, 0x0348, 0x60}, // Enable RX on link B, RX ID = 0

	{0x88, 0x02c7, 0x03}, // hawk2(0x88)max9295D MFP3-- gyro interrupt
	{0x88, 0x02c8, 0x15},
	{0x52, 0x0313, 0x00},
	{0x52, 0x034A, 0x05}, // max96712 MTF6---gyro2 interrupt
	{0x52, 0x034B, 0x75}, // MTF6

	{0x52, 0x0003, 0xFF}, // enable i2c channel B
	{0x52, 0x0007, 0x20},
	{0x52, 0x0003, 0xF6},

	{0x00, AR0234_TABLE_END, 0x00 }
};



static struct index_reg_8 ar0234_Single_Dser_Ser[] = {
	{0x52, 0x1458, 0x28},
	{0x52, 0x1459, 0x68},
	{0x52, 0x1558, 0x28},
	{0x52, 0x1559, 0x68},
	{0x52, 0x1658, 0x28},
	{0x52, 0x1659, 0x68},
	{0x52, 0x1758, 0x28},
	{0x52, 0x1759, 0x68},

	{0x52, 0x0018, 0x0F},
	{0x52, 0x0006, 0xF1},
	{0x52, 0x0001, 0xcc}, // disable the i2c2
	{0x80, 0x0010, 0x21},
	{0x80, 0x0330, 0x06},
	{0x80, 0x0332, 0x4E},
	{0x80, 0x0333, 0xE4},
	{0x80, 0x0331, 0x77},
	{0x80, 0x0311, 0x41},
	{0x80, 0x0308, 0x74},
	{0x80, 0x0314, 0x2B},
	{0x80, 0x0316, 0x22},
	{0x80, 0x0318, 0x2B},
	{0x80, 0x031A, 0x22},
	{0x80, 0x0002, 0xff},
	{0x80, 0x0053, 0x10},
	{0x80, 0x0057, 0x11},
	{0x80, 0x005B, 0x12},
	{0x80, 0x005F, 0x13},

	{0x52, 0x00F0, 0x20}, // pipx--pip0  pipz--pip1 gmsl phy A

	{0x52, 0x00F4, 0x03}, // enable pip 0/1

	{0x52, 0x08A0, 0x01},
	{0x52, 0x08A3, 0x44},
	{0x52, 0x08A4, 0x44},
	{0x52, 0x090A, 0x40},
	{0x52, 0x094A, 0x40},
	{0x52, 0x098A, 0x40},
	{0x52, 0x09CA, 0x40},
	{0x52, 0x0415, 0x2E},
	{0x52, 0x0418, 0x2E},
	{0x52, 0x041B, 0x2E},
	{0x52, 0x041E, 0x2E},

	{0x52, 0x090B, 0x07},
	{0x52, 0x092D, 0x15},
	{0x52, 0x090D, 0x2b},
	{0x52, 0x090E, 0x2b},
	{0x52, 0x090F, 0x00},
	{0x52, 0x0910, 0x00},
	{0x52, 0x0911, 0x01},
	{0x52, 0x0912, 0x01},

	{0x52, 0x094B, 0x07},
	{0x52, 0x096D, 0x15},
	{0x52, 0x094D, 0x2b},
	{0x52, 0x094E, 0x6b},
	{0x52, 0x094F, 0x00},
	{0x52, 0x0950, 0x40},
	{0x52, 0x0951, 0x01},
	{0x52, 0x0952, 0x41},

	{0x80, 0x02be, 0x90}, // Enable sensor power down pin.
	{0x80, 0x02bf, 0x60}, // Enable sensor reset pin.
	{0x80, 0x02ca, 0x80}, // Enable sensor power down pin.
	{0x80, 0x02cb, 0x60}, // Enable sensor reset pin.
	{0x80, 0x02d3, 0x90}, // Enable sensor power down pin.
	{0x80, 0x02d4, 0x60}, // Enable sensor reset pin.
	{0x80, 0x02d6, 0x90}, // Enable sensor power down pin.
	{0x80, 0x02d7, 0x60}, // Enable sensor reset pin.

	{0x52, 0x04AF, 0xC0}, // AUTO_FS_LINKS = 0, FS_USE_XTAL = 1, FS_LINK_[3:0] = 0
	{0x52, 0x04A0, 0x04}, // Manual frame sync, output on MFP2
	{0x52, 0x04A2, 0x00}, // Turn off auto master link selection
	{0x52, 0x04AA, 0x00}, // OVLP window = 0
	{0x52, 0x04AB, 0x00},
	{0x52, 0x04A5, 0x35}, // 30Hz FSYNC
	{0x52, 0x04A6, 0xB7},
	{0x52, 0x04A7, 0x0C},

	{0x80, 0x02D9, 0x04},
	{0x80, 0x02DB, 0x08}, // MFP8 for FSIN
	{0x80, 0x02Dc, 0x04},
	{0x80, 0x02De, 0x08}, // MFP8 for FSIN
	{0x52, 0x04B1, 0x40}, // FSYNC TX ID is 8

	{0x80, 0x0042, 0xB0}, // eeprom i2c map eeporm have two i2c address
	{0x80, 0x0043, 0xA8},
	{0x80, 0x0044, 0xB2},
	{0x80, 0x0045, 0xAA},

	{0x80, 0x02be, 0x83}, // hawk1(0x84) max9295D MFP0-- ACCEL interrupt
	{0x80, 0x02bf, 0x11},
	{0x52, 0x030c, 0x04}, // max96712 MTF4---ACCEL1 interrupt
	{0x52, 0x030e, 0x11}, // MTF4

	{0x80, 0x02c7, 0x83}, // hawk1(0x84)max9295D MFP3-- gyro interrupt
	{0x80, 0x02c8, 0x12},
	{0x52, 0x0320, 0x04}, // max96712 MTF10---gyro1 interrupt
	{0x52, 0x0322, 0x12}, // MTF10

	{0x00, AR0234_TABLE_END, 0x00 }
};

#else

static struct index_reg_8 ar0234_Double_Dser_Ser[] = {
	{ 0x94, 0x0010, 0x91 }, // RESET_ALL
	{ 0x80, 0x0010, 0x81 }, // RESET_ALL

	{ 0x00, AR0234_TABLE_END, 0x00 }
};

#if 1

static struct index_reg_8 ar0234_Single_Dser_Ser[] = {

	// MAX9296A 0x94
	// MAX9295D 0x80

	{ 0x94, 0x0010, 0x31 }, // RESET_ONESHOT
	{ 0x80, 0x0010, 0x21 }, // RESET_ONESHOT

	// { 0x80, 0x0330, 0x06 }, // No Virtual Channel mapping, Set SER to 2x4 mode (phy_config = 0)
	// defualt lane mapping
	// { 0x80, 0x0332, 0x4E }, // Verify lane map is at its default (phy1_lane_map = 4'hE, phy2_lane_map = 4'h4 )
	// { 0x80, 0x0333, 0xE4 }, // Additional lane map
	{ 0x80, 0x0331, 0x77 }, // Set 4 lanes for serializer (ctrl1_deskewen = 1, ctrl1_num_lanes = 3)
	{ 0x80, 0x0311, 0x41 }, // Start video from port A
	{ 0x80, 0x0308, 0x74 }, // Enable info lines. Additional start bits for Port A. Use data from port A for all pipelines.
	{ 0x80, 0x0314, 0x2B }, // Route RAW10 (DT = 0x2B) to VIDEO_X (Bit 6 enable)
	{ 0x80, 0x0316, 0x22 }, // Route RGB565 (DT = 0x22) to VIDEO_Y (Bit 6 enable)
	{ 0x80, 0x0318, 0x2B }, // Route RAW10 (DT = 0x2B) to VIDEO_Z (Bit 6 enable)
	{ 0x80, 0x031A, 0x22 }, // Route RGB565 (DT = 0x22) to VIDEO_U (Bit 6 enable)
	{ 0x80, 0x0002, 0xFF }, // Make sure all pipelines start transmission (VID_TX_EN_X/Y/Z/U = 1)
	{ 0x80, 0x0053, 0x10 }, // Pipe X stream select 0
	{ 0x80, 0x0057, 0x11 }, // Pipe Y stream select 1
	{ 0x80, 0x005B, 0x12 }, // Pipe Z stream select 2
	{ 0x80, 0x005F, 0x13 }, // Pipe U stream select 3


	// PHY0 D1 -> PHY1 D3, PHY0 D0 -> PHY1 D2, PHY1 in 1x4 lane
	// { 0x94, 0x0335, 0x03 }, // CameraBridge V3 BUG, Inverse polarity PHY1 D2/D3 (PHY0 D0/D1)

	// default 2x4 lane mode, change to 2x2 lane mode
	// { 0x94, 0x044A, 0x40 }, // Port A master in 2 lane mode
	// { 0x94, 0x048A, 0x40 }, // Port B master in 2 lane mode

	// { 0x94, 0x0330, 0x04 }, // 0x04 Set MIPI Phy Mode: 2x(1x4) mode, invalid max9296a
	// { 0x94, 0x0333, 0x4E }, // 0x4E lane maps - all 4 ports mapped straight
	// { 0x94, 0x0334, 0xE4 }, // 0xE4 Additional lane map

	// default 0x1F = 1.5Gbps
	// { 0x94, 0x031D, 0x34 }, // CSI PHY0 output frequency 2.0Gbps
	// { 0x94, 0x0320, 0x34 }, // 0x2F CSI PHY1 output frequency 2.0Gbps
	// { 0x94, 0x0323, 0x34 }, // CSI PHY2 output frequency 2.0Gbps
	// { 0x94, 0x0326, 0x34 }, // CSI PHY3 output frequency 2.0Gbps

	//
	{ 0x94, 0x0050, 0x01 }, // Route data from stream 1 to pipe X
	{ 0x94, 0x0051, 0x00 }, // Route data from stream 0 to pipe Y
	{ 0x94, 0x0052, 0x02 }, // Route data from stream 2 to pipe Z
	{ 0x94, 0x0053, 0x03 }, // Route data from stream 3 to pipe U

	{ 0x94, 0x030d, 0x02 }, // 0x00, ???, dist vs pipe Y

	{ 0x94, 0x048b, 0x07 }, // MIPI_TX_2 enable MAP_SRC_0/1/2 and MAP_DST_0/1/2
	{ 0x94, 0x04ad, 0x15 }, // MIPI_TX_2 MAP_SRC_0/1/2 MAP_DST_0/1/2 map to PHY1
	{ 0x94, 0x048d, 0x2b }, // MIPI_TX_2 MAP_SRC_0 set DT = RAW10(0x2B) VC = 0
	{ 0x94, 0x048e, 0x6b }, // MIPI_TX_2 MAP_DST_0 set DT = RAW10(0x2B) VC = 1
	{ 0x94, 0x048f, 0x40 }, // MIPI_TX_2 MAP_SRC_1 set DT = Frame Start Code(0x00) VC = 1
	{ 0x94, 0x0490, 0x40 }, // MIPI_TX_2 MAP_DST_2 set DT = Frame Start Code(0x00) VC = 1
	{ 0x94, 0x0491, 0x41 }, // MIPI_TX_2 MAP_SRC_1 set DT = Frame End Code(0x01) VC = 1
	{ 0x94, 0x0492, 0x41 }, // MIPI_TX_2 MAP_DST_0 set DT = Frame End Code(0x01) VC = 1

	{ 0x94, 0x0332, 0xF0 }, // All PHYs not in standby
	{ 0x80, 0x02be, 0x90 }, // MFP0 1MOhm GPIO_OUT
	{ 0x80, 0x02bf, 0x60 }, // MFP0 Pullup Push-pull GPIO_TX_ID = 0
	{ 0x80, 0x02ca, 0x80 }, // MFP4 1MOhm
	{ 0x80, 0x02cb, 0x60 }, // MFP4 Pullup Push-pull GPIO_TX_ID = 0

	{ 0x94, 0x0005, 0x00 }, // Disable LOCK and ERRB output
	{ 0x80, 0x02d3, 0x90 }, // MFP7 1MOhm GPIO_OUT
	{ 0x80, 0x02d4, 0x60 }, // MFP7 Pullup Push-pull GPIO_TX_ID = 0
	{ 0x80, 0x02d6, 0x90 }, // MFP8 1MOhm
	{ 0x80, 0x02d7, 0x60 }, // MFP8 Pullup Push-pull GPIO_TX_ID = 0

	{ 0x94, 0x03EF, 0xC0 }, // AUTO_FS_LINKS = 0, FS_USE_XTAL = 1, FS_LINK_[3:0] = 0
	{ 0x94, 0x03E2, 0x00 }, // MST_LINK_SEL = Video X(0b000), K_VAL = 0
	{ 0x94, 0x03EA, 0x00 }, // OVLP_WINDOW_L = 0
	{ 0x94, 0x03EB, 0x00 }, // OVLP_WINDOW_H = 0
	// { 0x94, 0x03E5, 0x35 }, // 30Hz FSYNC, 25Mhz / 30Hz = 833333(0x0CB735)
	// { 0x94, 0x03E6, 0xB7 },
	// { 0x94, 0x03E7, 0x0C },
	{ 0x94, 0x03E5, 0x9A }, // 60Hz FSYNC, 25Mhz / 60Hz = 416666(0x065B9A)
	{ 0x94, 0x03E6, 0x5B },
	{ 0x94, 0x03E7, 0x06 },
	// { 0x94, 0x03E5, 0x11 }, // 90Hz FSYNC, 25Mhz / 90Hz = 277777(0x043D11)
	// { 0x94, 0x03E6, 0x3D },
	// { 0x94, 0x03E7, 0x04 },
	// { 0x94, 0x03E5, 0xCD }, // 120Hz FSYNC, 25Mhz / 120Hz = 208333(0x032DCD)
	// { 0x94, 0x03E6, 0x2D },
	// { 0x94, 0x03E7, 0x03 },

	{ 0x94, 0x03F1, 0x40 }, // FSYNC_TX_ID = 0x08
	{ 0x94, 0x03E0, 0x04 }, // FSYNC manual, FSYNC on, output on MFP0

	{ 0x80, 0x02DB, 0x08 }, // MFP9 GPIO_RX_ID = 0x08, for FSYNC
	{ 0x80, 0x02D9, 0x04 }, // MFP9 GPIO_RX_EN = 1
	// { 0x94, 0x02B3, 0x83 }, // MFP1 1MOhm GPIO_TX_EN GPIO_OUT_DIS // GPIO TX compensation
	// { 0x94, 0x02B4, 0x10 }, // MFP1 GPIO_TX_ID = 16
	{ 0x80, 0x02DE, 0x08 }, // MFP10 GPIO_RX_ID = 0x08, for FSYNC
	{ 0x80, 0x02DC, 0x04 }, // MFP10 GPIO_RX_EN = 1

	{ 0x80, 0x02be, 0x83 }, // MFP0/INT1 GPIO_TX_EN GPIO_OUT_DIS
	{ 0x80, 0x02bf, 0x11 }, // MFP0/INT1 GPIO_TX_ID = 0x11
	{ 0x94, 0x02B3, 0x04 }, // MFP1 GPIO_RX_EN
	{ 0x94, 0x02B5, 0x11 }, // MFP1 GPIO_RX_ID = 0x11
	{ 0x94, 0x0003, 0x00 }, // Diable uart pass-through
	{ 0x80, 0x02c4, 0x83 }, // MFP2/INT3 GPIO_TX_EN GPIO_OUT_DIS
	{ 0x80, 0x02c5, 0x12 }, // MFP2/INT3 GPIO_TX_ID = 0x12
	{ 0x94, 0x02BC, 0x04 }, // MFP4 GPIO_RX_EN
	{ 0x94, 0x02BE, 0x12 }, // MFP4 GPIO_RX_ID = 0x12

	// { 0x80, 0x0042, 0xB0 }, // SRC_A = 0xB0/0x58
	// { 0x80, 0x0043, 0xA8 }, // DST_A = 0xA8/0x54

	// { 0x80, 0x0044, 0xB2 }, // SRC_B = 0xB2/0x59
	// { 0x80, 0x0045, 0xAA }, // DST_B = 0xAA/0x55

	{ 0x00, AR0234_TABLE_END, 0x00 }
};

#else

static struct index_reg_8 ar0234_Single_Dser_Ser[] = {

	{0x94, 0x0010, 0x31}, // Apply Reset Oneshot for changes
	{0x80, 0x0010, 0x21}, // Apply Reset Oneshot for changes
	{0x80, 0x0330, 0x06}, // No Virtual Channel mapping, Set SER to 2x4 mode (phy_config = 0)
	{0x80, 0x0332, 0x4E}, // Verify lane map is at its default (phy1_lane_map = 4'hE, phy2_lane_map = 4'h4 )
	{0x80, 0x0333, 0xE4}, // Additional lane map
	{0x80, 0x0331, 0x77}, // Set 4 lanes for serializer (ctrl1_num_lanes = 3)
	{0x80, 0x0311, 0x41}, // Start video from port A
	{0x80, 0x0308, 0x74}, // Enable info lines. Additional start bits for Port A. Use data from port A for all pipelines.
	{0x80, 0x0314, 0x2B}, // Route 16bit DCG (DT = 0x30) to VIDEO_X (Bit 6 enable)
	{0x80, 0x0316, 0x22}, // Route 12bit RAW (DT = 0x2C) to VIDEO_Y (Bit 6 enable)
	{0x80, 0x0318, 0x2B}, // Route EMBEDDED8 to VIDEO_Z (Bit 6 enable)
	{0x80, 0x031A, 0x22}, // Unused VIDEO_U
	{0x80, 0x0002, 0xff}, // Make sure all pipelines start transmission (VID_TX_EN_X/Y/Z/U = 1)
	{0x80, 0x0053, 0x10}, // Pipe X stream select 0
	{0x80, 0x0057, 0x11}, // Pipe Y stream select 2
	{0x80, 0x005B, 0x12}, // Pipe Z stream select 1
	{0x80, 0x005F, 0x13}, // Pipe U stream select 3
	{0x94, 0x0330, 0x04}, // Set MIPI Phy Mode: 2x(1x4) mode
	{0x94, 0x0333, 0x4E}, // lane maps - all 4 ports mapped straight
	{0x94, 0x0334, 0xE4}, // Additional lane map
	{0x94, 0x040A, 0x00}, // lane count - 0 lanes striping on controller 0 (Port A slave in 2x1x4 mode).
	{0x94, 0x044A, 0x40}, // lane count - 4 lanes striping on controller 1 (Port A master in 2x1x4 mode).
	{0x94, 0x048A, 0x40}, // lane count - 4 lanes striping on controller 2 (Port B master in 2x1x4 mode).
	{0x94, 0x04CA, 0x00}, // lane count - 0 lanes striping on controller 3 (Port B slave in 2x1x4 mode).
	{0x94, 0x031D, 0x39}, // MIPI clock rate -  from controller 0 clock (Port A slave in 2x1x4 mode).
	{0x94, 0x0320, 0x39}, // MIPI clock rate - 600Mbps from controller 1 clock (Port A master in 2x1x4 mode).
	{0x94, 0x0323, 0x39}, // MIPI clock rate -  from controller 2 clock (Port B master in 2x1x4 mode).
	{0x94, 0x0326, 0x39}, // MIPI clock rate -  from controller 2 clock (Port B slave in 2x1x4 mode).
	{0x94, 0x0050, 0x01}, // Route data from stream 0 to pipe X
	{0x94, 0x0051, 0x00}, // Route data from stream 0 to pipe Y
	{0x94, 0x0052, 0x02}, // Route data from stream 0 to pipe Z
	{0x94, 0x0053, 0x03}, // Route data from stream 0 to pipe U
	{0x94, 0x030d, 0x02}, // dist vs pip y
	{0x94, 0x048b, 0x07}, // use map0 for vc for  pip Y
	{0x94, 0x04ad, 0x15}, // map to phy1 pip y
	{0x94, 0x048d, 0x2b}, // source vs pip y
	{0x94, 0x048e, 0x6b}, // dist vs pip y

	{0x94, 0x048f, 0x40}, // dist vs pip y
	{0x94, 0x0490, 0x40}, // dist vs pip y
	{0x94, 0x0491, 0x41}, // dist vs pip y
	{0x94, 0x0492, 0x41}, // dist vs pip y

	{0x94, 0x0332, 0xF0},
	{0x80, 0x02be, 0x90}, // Enable sensor power down pin.
	{0x80, 0x02bf, 0x60}, // Enable sensor reset pin.
	{0x80, 0x02ca, 0x80}, // Enable sensor power down pin.
	{0x80, 0x02cb, 0x60}, // Enable sensor reset pin.
	{0x94, 0x0005, 0x00},
	{0x80, 0x02d3, 0x90}, // Enable sensor power down pin.
	{0x80, 0x02d4, 0x60}, // Enable sensor reset pin.
	{0x80, 0x02d6, 0x90}, // Enable sensor power down pin.
	{0x80, 0x02d7, 0x60}, // Enable sensor reset pin.

	{0x94, 0x03EF, 0xC0}, // AUTO_FS_LINKS = 0, FS_USE_XTAL = 1, FS_LINK_[3:0] = 0
	{0x94, 0x03E2, 0x00}, // Turn off auto master link selection
	{0x94, 0x03EA, 0x00}, // OVLP window = 0
	{0x94, 0x03EB, 0x00},
	// {0x94,0x03E5,0x35},	// 30Hz FSYNC
	// {0x94,0x03E6,0xB7},
	// {0x94,0x03E7,0x0C},
	// { 0x94, 0x03E5, 0x9A }, // 60Hz FSYNC
	// { 0x94, 0x03E6, 0x5B },
	// { 0x94, 0x03E7, 0x06 },
	{0x94, 0x03E5, 0xCD}, // 120Hz FSYNC
	{0x94, 0x03E6, 0x2D},
	{0x94, 0x03E7, 0x03},

	{0x94, 0x03F1, 0x40}, // FSYNC TX ID is 8
	{0x94, 0x03E0, 0x04}, // Enable manual frame sync, output on MFP0

	{0x80, 0x02DB, 0x08}, // MFP8 for FSIN
	{0x80, 0x02D9, 0x04},
	//{0x94,0x02B3,0x83},//GPIO TX compensation
	//{0x94,0x02B4,0x10},
	{0x80, 0x02De, 0x08}, // MFP8 for FSIN
	{0x80, 0x02Dc, 0x04},

	{0x80, 0x02be, 0x83},
	{0x80, 0x02bf, 0x11},
	{0x94, 0x02B3, 0x04},
	{0x94, 0x02B5, 0x11},
	{0x94, 0x0003, 0x40},
	{0x80, 0x02c4, 0x83},
	{0x80, 0x02c5, 0x12},
	{0x94, 0x02BC, 0x04},
	{0x94, 0x02BE, 0x12},

	{0x80, 0x0042, 0xB0},
	{0x80, 0x0043, 0xA8},

	{0x80, 0x0044, 0xB2},
	{0x80, 0x0045, 0xAA},

	{0x00, AR0234_TABLE_END, 0x00}};

#endif


#endif

static struct index_reg_8 ar0234_1920x1200_full[] = {
	{0x06, 0x301A, 0x00D9}, // reset
	{0x06, AR0234_TABLE_WAIT_MS, 100},

	/** init sequence */
	{0x06, 0x3F4C, 0x121F},
	{0x06, 0x3F4E, 0x121F},
	{0x06, 0x3F50, 0x0B81},
	{0x06, 0x31E0, 0x0003},
	// {0x06, 0x30B0, 0x0028}, // digital_test

	/** sequencer ram */
	{0x06, 0x3088, 0x8000}, // seq_ctrl_port, address 0x00
	{0x06, 0x3086, 0xC1AE}, // seq_data_port
	{0x06, 0x3086, 0x327F},
	{0x06, 0x3086, 0x5780},
	{0x06, 0x3086, 0x272F},
	{0x06, 0x3086, 0x7416},
	{0x06, 0x3086, 0x7E13},
	{0x06, 0x3086, 0x8000},
	{0x06, 0x3086, 0x307E},
	{0x06, 0x3086, 0xFF80},
	{0x06, 0x3086, 0x20C3},
	{0x06, 0x3086, 0xB00E},
	{0x06, 0x3086, 0x8190},
	{0x06, 0x3086, 0x1643},
	{0x06, 0x3086, 0x1651},
	{0x06, 0x3086, 0x9D3E},
	{0x06, 0x3086, 0x9545},
	{0x06, 0x3086, 0x2209},
	{0x06, 0x3086, 0x3781},
	{0x06, 0x3086, 0x9016},
	{0x06, 0x3086, 0x4316},
	{0x06, 0x3086, 0x7F90},
	{0x06, 0x3086, 0x8000},
	{0x06, 0x3086, 0x387F},
	{0x06, 0x3086, 0x1380},
	{0x06, 0x3086, 0x233B},
	{0x06, 0x3086, 0x7F93},
	{0x06, 0x3086, 0x4502},
	{0x06, 0x3086, 0x8000},
	{0x06, 0x3086, 0x7FB0},
	{0x06, 0x3086, 0x8D66},
	{0x06, 0x3086, 0x7F90},
	{0x06, 0x3086, 0x8192},
	{0x06, 0x3086, 0x3C16},
	{0x06, 0x3086, 0x357F},
	{0x06, 0x3086, 0x9345},
	{0x06, 0x3086, 0x0280},
	{0x06, 0x3086, 0x007F},
	{0x06, 0x3086, 0xB08D},
	{0x06, 0x3086, 0x667F},
	{0x06, 0x3086, 0x9081},
	{0x06, 0x3086, 0x8237},
	{0x06, 0x3086, 0x4502},
	{0x06, 0x3086, 0x3681},
	{0x06, 0x3086, 0x8044},
	{0x06, 0x3086, 0x1631},
	{0x06, 0x3086, 0x4374},
	{0x06, 0x3086, 0x1678},
	{0x06, 0x3086, 0x7B7D},
	{0x06, 0x3086, 0x4502},
	{0x06, 0x3086, 0x450A},
	{0x06, 0x3086, 0x7E12},
	{0x06, 0x3086, 0x8180},
	{0x06, 0x3086, 0x377F},
	{0x06, 0x3086, 0x1045},
	{0x06, 0x3086, 0x0A0E},
	{0x06, 0x3086, 0x7FD4},
	{0x06, 0x3086, 0x8024},
	{0x06, 0x3086, 0x0E82},
	{0x06, 0x3086, 0x9CC2},
	{0x06, 0x3086, 0xAFA8},
	{0x06, 0x3086, 0xAA03},
	{0x06, 0x3086, 0x430D},
	{0x06, 0x3086, 0x2D46},
	{0x06, 0x3086, 0x4316},
	{0x06, 0x3086, 0x5F16},
	{0x06, 0x3086, 0x530D},
	{0x06, 0x3086, 0x1660},
	{0x06, 0x3086, 0x401E},
	{0x06, 0x3086, 0x2904},
	{0x06, 0x3086, 0x2984},
	{0x06, 0x3086, 0x81E7},
	{0x06, 0x3086, 0x816F},
	{0x06, 0x3086, 0x1706},
	{0x06, 0x3086, 0x81E7},
	{0x06, 0x3086, 0x7F81},
	{0x06, 0x3086, 0x5C0D},
	{0x06, 0x3086, 0x5754},
	{0x06, 0x3086, 0x495F},
	{0x06, 0x3086, 0x5305},
	{0x06, 0x3086, 0x5307},
	{0x06, 0x3086, 0x4D2B},
	{0x06, 0x3086, 0xF810},
	{0x06, 0x3086, 0x164C},
	{0x06, 0x3086, 0x0755},
	{0x06, 0x3086, 0x562B},
	{0x06, 0x3086, 0xB82B},
	{0x06, 0x3086, 0x984E},
	{0x06, 0x3086, 0x1129},
	{0x06, 0x3086, 0x9460},
	{0x06, 0x3086, 0x5C09},
	{0x06, 0x3086, 0x5C1B},
	{0x06, 0x3086, 0x4002},
	{0x06, 0x3086, 0x4500},
	{0x06, 0x3086, 0x4580},
	{0x06, 0x3086, 0x29B6},
	{0x06, 0x3086, 0x7F80},
	{0x06, 0x3086, 0x4004},
	{0x06, 0x3086, 0x7F88},
	{0x06, 0x3086, 0x4109},
	{0x06, 0x3086, 0x5C0B},
	{0x06, 0x3086, 0x29B2},
	{0x06, 0x3086, 0x4115},
	{0x06, 0x3086, 0x5C03},
	{0x06, 0x3086, 0x4105},
	{0x06, 0x3086, 0x5F2B},
	{0x06, 0x3086, 0x902B},
	{0x06, 0x3086, 0x8081},
	{0x06, 0x3086, 0x6F40},
	{0x06, 0x3086, 0x1041},
	{0x06, 0x3086, 0x0160},
	{0x06, 0x3086, 0x29A2},
	{0x06, 0x3086, 0x29A3},
	{0x06, 0x3086, 0x5F4D},
	{0x06, 0x3086, 0x1C17},
	{0x06, 0x3086, 0x0281},
	{0x06, 0x3086, 0xE729},
	{0x06, 0x3086, 0x8345},
	{0x06, 0x3086, 0x8840},
	{0x06, 0x3086, 0x0F7F},
	{0x06, 0x3086, 0x8A40},
	{0x06, 0x3086, 0x2345},
	{0x06, 0x3086, 0x8024},
	{0x06, 0x3086, 0x4008},
	{0x06, 0x3086, 0x7F88},
	{0x06, 0x3086, 0x5D29},
	{0x06, 0x3086, 0x9288},
	{0x06, 0x3086, 0x102B},
	{0x06, 0x3086, 0x0489},
	{0x06, 0x3086, 0x165C},
	{0x06, 0x3086, 0x4386},
	{0x06, 0x3086, 0x170B},
	{0x06, 0x3086, 0x5C03},
	{0x06, 0x3086, 0x8A48},
	{0x06, 0x3086, 0x4D4E},
	{0x06, 0x3086, 0x2B80},
	{0x06, 0x3086, 0x4C09},
	{0x06, 0x3086, 0x4119},
	{0x06, 0x3086, 0x816F},
	{0x06, 0x3086, 0x4110},
	{0x06, 0x3086, 0x4001},
	{0x06, 0x3086, 0x6029},
	{0x06, 0x3086, 0x8229},
	{0x06, 0x3086, 0x8329},
	{0x06, 0x3086, 0x435C},
	{0x06, 0x3086, 0x055F},
	{0x06, 0x3086, 0x4D1C},
	{0x06, 0x3086, 0x81E7},
	{0x06, 0x3086, 0x4502},
	{0x06, 0x3086, 0x8180},
	{0x06, 0x3086, 0x7F80},
	{0x06, 0x3086, 0x410A},
	{0x06, 0x3086, 0x9144},
	{0x06, 0x3086, 0x1609},
	{0x06, 0x3086, 0x2FC3},
	{0x06, 0x3086, 0xB130},
	{0x06, 0x3086, 0xC3B1},
	{0x06, 0x3086, 0x0343},
	{0x06, 0x3086, 0x164A},
	{0x06, 0x3086, 0x0A43},
	{0x06, 0x3086, 0x160B},
	{0x06, 0x3086, 0x4316},
	{0x06, 0x3086, 0x8F43},
	{0x06, 0x3086, 0x1690},
	{0x06, 0x3086, 0x4316},
	{0x06, 0x3086, 0x7F81},
	{0x06, 0x3086, 0x450A},
	{0x06, 0x3086, 0x410F},
	{0x06, 0x3086, 0x7F83},
	{0x06, 0x3086, 0x5D29},
	{0x06, 0x3086, 0x4488},
	{0x06, 0x3086, 0x102B},
	{0x06, 0x3086, 0x0453},
	{0x06, 0x3086, 0x0D40},
	{0x06, 0x3086, 0x2345},
	{0x06, 0x3086, 0x0240},
	{0x06, 0x3086, 0x087F},
	{0x06, 0x3086, 0x8053},
	{0x06, 0x3086, 0x0D89},
	{0x06, 0x3086, 0x165C},
	{0x06, 0x3086, 0x4586},
	{0x06, 0x3086, 0x170B},
	{0x06, 0x3086, 0x5C05},
	{0x06, 0x3086, 0x8A60},
	{0x06, 0x3086, 0x4B91},
	{0x06, 0x3086, 0x4416},
	{0x06, 0x3086, 0x09C1},
	{0x06, 0x3086, 0x2CA9},
	{0x06, 0x3086, 0xAB30},
	{0x06, 0x3086, 0x51B3},
	{0x06, 0x3086, 0x3D5A},
	{0x06, 0x3086, 0x7E3D},
	{0x06, 0x3086, 0x7E19},
	{0x06, 0x3086, 0x8000},
	{0x06, 0x3086, 0x8B1F},
	{0x06, 0x3086, 0x2A1F},
	{0x06, 0x3086, 0x83A2},
	{0x06, 0x3086, 0x7516},
	{0x06, 0x3086, 0xAD33},
	{0x06, 0x3086, 0x450A},
	{0x06, 0x3086, 0x7F53},
	{0x06, 0x3086, 0x8023},
	{0x06, 0x3086, 0x8C66},
	{0x06, 0x3086, 0x7F13},
	{0x06, 0x3086, 0x8184},
	{0x06, 0x3086, 0x1481},
	{0x06, 0x3086, 0x8031},
	{0x06, 0x3086, 0x3D64},
	{0x06, 0x3086, 0x452A},
	{0x06, 0x3086, 0x9451},
	{0x06, 0x3086, 0x9E96},
	{0x06, 0x3086, 0x3D2B},
	{0x06, 0x3086, 0x3D1B},
	{0x06, 0x3086, 0x529F},
	{0x06, 0x3086, 0x0E3D},
	{0x06, 0x3086, 0x083D},
	{0x06, 0x3086, 0x167E},
	{0x06, 0x3086, 0x307E},
	{0x06, 0x3086, 0x1175},
	{0x06, 0x3086, 0x163E},
	{0x06, 0x3086, 0x970E},
	{0x06, 0x3086, 0x82B2},
	{0x06, 0x3086, 0x3D7F},
	{0x06, 0x3086, 0xAC3E},
	{0x06, 0x3086, 0x4502},
	{0x06, 0x3086, 0x7E11},
	{0x06, 0x3086, 0x7FD0},
	{0x06, 0x3086, 0x8000},
	{0x06, 0x3086, 0x8C66},
	{0x06, 0x3086, 0x7F90},
	{0x06, 0x3086, 0x8194},
	{0x06, 0x3086, 0x3F44},
	{0x06, 0x3086, 0x1681},
	{0x06, 0x3086, 0x8416},
	{0x06, 0x3086, 0x2C2C},
	{0x06, 0x3086, 0x2C2C},

	/** PIXCLK = (EXTCLK *  pll_multiplier) / (pre_pll_clk_div * vt_sys_clk_div * vt_pix_clk_div) */

#if 0

	/** pclk = 33.75mhz = (27mhz * 150) / (6 * 4 * 5) */
	{0x06, 0x302A, 0x0005}, // vt_pix_clk_div = 5 *
	{0x06, 0x302C, 0x0001}, // vt_sys_clk_div = 1 *
	{0x06, 0x302E, 0x0003}, // pre_pll_clk_div = 3 * 
	{0x06, 0x3030, 0x0096}, // pll_multiplier = 150
	{0x06, 0x302E, 0x0006}, // pre_pll_clk_div = 6
	{0x06, 0x302C, 0x0004}, // vt_sys_clk_div = 4
	{0x06, 0x302A, 0x0005}, // vt_pix_clk_div = 5
	{0x06, 0x3038, 0x0004}, // op_pix_clk_div = 4
	{0x06, 0x3036, 0x000A}, // op_sys_clk_div = 10
	{0x06, 0x31B0, 0x002F}, // frame_preamble
	{0x06, 0x31B2, 0x002C}, // line_preamble
	{0x06, 0x31B4, 0x1144}, // mipi_timing_0
	{0x06, 0x31B6, 0x00C7}, // mipi_timing_1
	{0x06, 0x31B8, 0x3047}, // mipi_timing_2
	{0x06, 0x31BA, 0x0103}, // mipi_timing_3
	{0x06, 0x31BC, 0x8583}, // mipi_timing_4
	{0x06, 0x31AE, 0x0204}, // serial_format, 4 lanes
	{0x06, 0x3002, 0x0008}, // y_addr_start = 8
	{0x06, 0x3004, 0x0008}, // x_addr_start = 8
	{0x06, 0x3006, 0x04B7}, // y_addr_end = 1207
	{0x06, 0x3008, 0x0787}, // x_addr_end = 1927
	{0x06, 0x300A, 0x04C6}, // frame_length_lines, 1222, ORIG: 1216
	{0x06, 0x300C, 0x0264}, // line_length_pck = 612
	{0x06, 0x3012, 0x02DC}, // coarse_integration_time = 732
	{0x06, 0x31AC, 0x0A0A}, // data_format_bits = 2570
	{0x06, 0x306E, 0x9010}, // datapath_select, true_bayer = 1
	{0x06, 0x30A2, 0x0001}, // x_odd_inc, no skip
	{0x06, 0x30A6, 0x0001}, // y_odd_inc, no skip
	{0x06, 0x3082, 0x0003}, // operation_mode_ctrl = 3
	{0x06, 0x3040, 0x0000}, // read_mode = 0
	{0x06, 0x31D0, 0x0000}, // compression = 0

#else

	/** pclk = 57.6mhz = (27mhz * 32) / (3 * 1 * 5) */
	/** pclk = 90.0mhz = (27mhz * 50) / (3 * 1 * 5) */
	{0x06, 0x302A, 0x0005}, // vt_pix_clk_div = 5
	{0x06, 0x302C, 0x0001}, // vt_sys_clk_div = 1
	{0x06, 0x302E, 0x0003}, // pre_pll_clk_div = 3
	// {0x06, 0x3030, 0x0030}, // pll_multiplier = 48
	// {0x06, 0x3030, 0x0020}, // pll_multiplier = 32
	{0x06, 0x3030, 0x0032}, // pll_multiplier = 50

	{0x06, 0x3036, 0x000A}, // op_pix_clk_div = 10
	{0x06, 0x3038, 0x0001}, // op_sys_clk_div = 1
	// {0x06, 0x30B0, 0x0028}, // digital_test
	// {0x06, 0x31B0, 0x0082}, // frame_preamble
	// {0x06, 0x31B2, 0x005C}, // line_preamble
	// {0x06, 0x31B4, 0x5248}, // mipi_timing_0
	// {0x06, 0x31B6, 0x3257}, // mipi_timing_1
	// {0x06, 0x31B8, 0x904B}, // mipi_timing_2
	// {0x06, 0x31BA, 0x030B}, // mipi_timing_3
	// {0x06, 0x31BC, 0x8E09}, // mipi_timing_4
	{0x06, 0x3354, 0x002B}, // mipi_ctrl
	{0x06, 0x31AE, 0x0204}, // serial_format, 4 lanes
	{0x06, 0x3002, 0x0008}, // y_addr_start = 8
	{0x06, 0x3004, 0x0008}, // x_addr_start = 8
	{0x06, 0x3006, 0x04B7}, // y_addr_end = 1207
	{0x06, 0x3008, 0x0787}, // x_addr_end = 1927
	// {0x06, 0x300A, 0x04c8}, // frame_length_lines = 1224
	{0x06, 0x300A, 0x04C0}, // frame_length_lines = 1216
	// {0x06, 0x300A, 0x0480}, // frame_length_lines = 1152
	// {0x06, 0x300A, 0x0400}, // frame_length_lines = 1024
	// {0x06, 0x300C, 0x04C4}, // line_length_pck = 1220
	// {0x06, 0x300C, 0x0648}, // line_length_pck = 1608
	// {0x06, 0x300C, 0x0268}, // line_length_pck = 616
	{0x06, 0x300C, 0x0264}, // line_length_pck = 612
	// {0x06,0x3012, 0x02DC}, // coarse_integration_time = 732
	{0x06, 0x3012, 0x00DC}, // coarse_integration_time = 220
	{0x06, 0x31AC, 0x0A0A}, // data_format_bits = 2570
	{0x06, 0x306E, 0x9010}, // datapath_select, true_bayer = 1
	{0x06, 0x30A2, 0x0001}, // x_odd_inc, no skip
	{0x06, 0x30A6, 0x0001}, // y_odd_inc, no skip
	{0x06, 0x3082, 0x0003}, // operation_mode_ctrl = 3
	{0x06, 0x3040, 0x0000}, // read_mode
	// {0x06, 0x31D0, 0x0000}, // compression = 0
	// {0x06, 0x301A, 0x205C}, // stream = 1
	{0x06, AR0234_TABLE_WAIT_MS, 100},

#endif

	/** reserved sequence */
	{0x06, 0x3044, 0x0410},
	{0x06, 0x3094, 0x03D4},
	{0x06, 0x3096, 0x0480},
	{0x06, 0x30BA, 0x7602},
	{0x06, 0x30B0, 0x0028},
	{0x06, 0x30FE, 0x002A},
	{0x06, 0x31DE, 0x0410},
	{0x06, 0x3ED6, 0x1435},
	{0x06, 0x3ED8, 0x9865},
	{0x06, 0x3EDA, 0x7698},
	{0x06, 0x3EDC, 0x99FF},
	{0x06, 0x3EE2, 0xBB88},
	{0x06, 0x3EE4, 0x8836},
	{0x06, 0x3EF0, 0x1CF0},
	{0x06, 0x3EF2, 0x0000},
	{0x06, 0x3EF8, 0x6166},
	{0x06, 0x3EFA, 0x3333},
	{0x06, 0x3EFC, 0x6634},
	{0x06, 0x3276, 0x05DC},
	{0x06, 0x3F00, 0x9D05},
	{0x06, 0x3ED2, 0xFA86},
	{0x06, 0x3EEE, 0xA4FE},
	{0x06, 0x30BA, 0x7602},
	{0x06, 0x3180, 0xC24F},
	{0x06, 0x3ECC, 0x6E42},
	{0x06, 0x3ECC, 0x0E42},
	{0x06, 0x3EEC, 0x0C0C},
	{0x06, 0x3EE8, 0xAAE4},
	{0x06, 0x3EE6, 0x3363},
	{0x06, 0x3EE6, 0x3363},
	{0x06, 0x3EE8, 0xAAE4},
	{0x06, 0x3EE8, 0xAAE4},
	{0x06, 0x3102, 0x5000},
	{0x06, 0x3060, 0x000D},
	{0x06, 0x3ED0, 0xFF44},
	{0x06, 0x3ED2, 0xAA86},
	{0x06, 0x3ED4, 0x031F},
	{0x06, 0x3EEE, 0xA4AA},

	{0x06, 0x301A, 0x2058}, // stream = 0

	{0x00, AR0234_TABLE_END, 0x00},
};

static struct index_reg_8 ar0234_960x600_binning[] = {
	{0x06, 0x301A, 0x00D9}, // reset
	{0x06, AR0234_TABLE_WAIT_MS, 100},

	/** init sequence */
	{0x06, 0x3F4C, 0x121F},
	{0x06, 0x3F4E, 0x121F},
	{0x06, 0x3F50, 0x0B81},
	{0x06, 0x31E0, 0x0003},
	// {0x06, 0x30B0, 0x0000}, // digital_test

	/** context */
	{0x06, 0x302A, 0x0005}, // vt_pix_clk_div = 5
	{0x06, 0x302C, 0x0001}, // vt_sys_clk_div = 1
	{0x06, 0x302E, 0x0003}, // pre_pll_clk_div = 3
	{0x06, 0x3030, 0x0032}, // pll_multiplier = 50
	{0x06, 0x3036, 0x000A}, // op_pix_clk_div = 10
	{0x06, 0x3038, 0x0001}, // op_sys_clk_div = 1
	// {0x06, 0x30B0, 0x0000}, // digital_test = 0
	// {0x06, 0x31B0, 0x0082}, // frame_preamble
	// {0x06, 0x31B2, 0x005C}, // line_preamble
	// {0x06, 0x31B4, 0x51C8}, // mipi_timing_0
	// {0x06, 0x31B6, 0x3257}, // mipi_timing_1
	// {0x06, 0x31B8, 0x904B}, // mipi_timing_2
	// {0x06, 0x31BA, 0x030B}, // mipi_timing_3
	// {0x06, 0x31BC, 0x8E09}, // mipi_timing_4
	// {0x06, 0x3354, 0x002B}, // mipi_ctrl
	// {0x06, 0x31D0, 0x0000}, // compression = 0
	{0x06, 0x31AE, 0x0204}, // serial_format, 4 lanes
	{0x06, 0x3002, 0x0008}, // y_addr_start = 8
	{0x06, 0x3004, 0x0008}, // x_addr_start = 8
	{0x06, 0x3006, 0x04B7}, // y_addr_end = 1207
	{0x06, 0x3008, 0x0787}, // x_addr_end = 1927
	{0x06, 0x3064, 0x1802}, // embedded_data_ctrl
	{0x06, 0x300A, 0x04C0}, // frame_length_lines = 616
	{0x06, 0x300C, 0x0264}, // line_length_pck = 612
	{0x06, 0x30A2, 0x0003}, // x_odd_inc, skip_factor = 2
	{0x06, 0x30A6, 0x0003}, // y_odd_inc, skip_factor = 2
	{0x06, 0x3012, 0x024C}, // coarse_integration_time = 588
	{0x06, 0x3786, 0x0006},
	{0x06, 0x31AC, 0x0A0A}, // data_format_bits
	{0x06, 0x306E, 0x9010}, // datapath_select, true_bayer = 1
	{0x06, 0x3082, 0x0003}, // operation_mode_ctrl
	{0x06, 0x3040, 0x3000}, // read_mode, col_bin = 1, row_bin = 1
	// {0x06, 0x3040, 0x1200}, // read_mode, col_sf_bin_en = 1, row_bin = 1
	// {0x06, 0x3040, 0x0000}, // read_mode, skip only

	/** sequencer ram */
	// {0x06, 0x30B0, 0x0028}, // digital_test, mono_chrome = 0, col_gain = 4
	{0x06, 0x3088, 0x8050}, // seq_ctrl_port, address 0x50
	{0x06, 0x3086, 0x9237}, // seq_data_port

	/** reserved sequence */
	{0x06, 0x3096, 0x0280},
	{0x06, 0x3180, 0xC24F},
	{0x06, 0x3ECC, 0x0E42},
	{0x06, 0x30BA, 0x7602}, // digital_ctrl
	{0x06, 0x30F0, 0x2283}, // RESERVED_CHIPREV
	{0x06, 0x3102, 0x5000}, // ae_luma_target_reg
	{0x06, 0x3060, 0x000D}, // analog_gain
	{0x06, 0x3ED2, 0xAA00},
	{0x06, 0x3EEE, 0xA4AA},

	{0x00, AR0234_TABLE_END, 0x00},
};

static struct index_reg_8 ar0234_1920x960_crop[] = {
	{0x00, AR0234_TABLE_END, 0x00},
};

static struct index_reg_8 tp_colorbars[] = {
	{0x06, 0x3070, 0x2},

	{0x00, AR0234_TABLE_END, 0x00},
};

enum {
	AR0234_MODE_1920X1200_FULL,
	AR0234_MODE_960x600_BINNING,
	AR0234_MODE_1920X960_CROP,
	AR0234_MODE_START_STREAM,
	AR0234_MODE_STOP_STREAM,
	AR0234_MODE_Double_Dser_Ser,
	AR0234_MODE_Single_Dser_Ser,
	AR0234_MODE_HAWK_SERDES,
	AR0234_MODE_DUAL_HAWK_SERDES,
	AR0234_MODE_TEST_PATTERN
};

static struct index_reg_8 *mode_table[] = {
	[AR0234_MODE_1920X1200_FULL] = ar0234_1920x1200_full,
	[AR0234_MODE_960x600_BINNING] = ar0234_960x600_binning,
	[AR0234_MODE_1920X960_CROP] = ar0234_1920x960_crop,
	[AR0234_MODE_START_STREAM] = ar0234_start,
	[AR0234_MODE_STOP_STREAM] = ar0234_stop,
	[AR0234_MODE_Double_Dser_Ser] = ar0234_Double_Dser_Ser,
	[AR0234_MODE_Single_Dser_Ser] = ar0234_Single_Dser_Ser,
	[AR0234_MODE_TEST_PATTERN] = tp_colorbars,

};

static const int ar0234_30fps[] = {
	30,
};

static const int ar0234_60fps[] = {
	30,
	60,
};

static const int ar0234_90fps[] = {
	30,
	60,
	90,
};

static const int ar0234_120fps[] = {
	30,
	60,
	90,
	120,
};
static const struct camera_common_frmfmt ar0234_frmfmt[] = {
	{{1920, 1200}, ar0234_90fps, 3, 0, AR0234_MODE_1920X1200_FULL},
	{{960, 600}, ar0234_120fps, 4, 0, AR0234_MODE_960x600_BINNING},
	{{1920, 960}, ar0234_120fps, 4, 0, AR0234_MODE_1920X960_CROP},
};
#endif /* __AR0234_I2C_TABLES__ */
